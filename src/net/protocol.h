/*
   BtSoccer - button football (soccer) game
   Copyright (C) 2008-2015 DNTeam <btsoccer@dnteam.org>

   This file is part of BtSoccer.

   BtSoccer is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   BtSoccer is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with BtSoccer.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef _btsoccer_protocol_h
#define _btsoccer_protocol_h

#include <OGRE/Ogre.h>
#include <pthread.h>
#include <kobold/timer.h>

namespace BtSoccer
{

/*! Time before try to resend. */
#define PROTOCOL_TIME_TO_RESEND_MS  2000
   
#define PROTOCOL_DATA_SIZE 253
#define PROTOCOL_INC_SIZE    4 // must not be greater than unsigned long size.

/*! =================================================== *
 *  | MSG_TYPE | Need Ack | inc    | DATA             | *
 *  =================================================== *
 *  |  1 Byte  |  1 Byte  | 4 Byte | 250 Bytes        | *
 *  =================================================== * 
 *  |                    256 Bytes                    | *
 *  =================================================== */
typedef struct _ProtocolMessage
{
   /*! Message type */
   char type;
   /*! If message need ack. */
   char needAck;
   /*! Sequential Incremented value to distinguish messages.
    * 4 bytes should be enough. */
   char inc[PROTOCOL_INC_SIZE];
   /*! The data of the message */
   char data[PROTOCOL_DATA_SIZE];
}ProtocolMessage;

/*! The parsed message generated by a received protocol message.
 * \note One ProtocolMessage can generate more than one ProtocolParsedMessage,
 *       for example, an MESSAGE_UPDATE_POSITIONS will generate one
 *       ProtocolParsedMessage for each position received. */
typedef struct _ProtocolParsedMessage
{
   public:
      char msgType;  /**< Type of the original message.  */
      char msgInfo;  /**< Info about the original message wich derivates
                          the current parsed one. 
                          For Example: UPDATE_TYPE_TEAM_A
                          For Example: rule state constant  */
      char msgAditionalInfo; /**< Aditional info about the original message.
                                  For example: disk number. */
      Ogre::Vector3 position; /**< Position related to the parsed message  */
      Ogre::Quaternion angles; /**< Orientation related to the parsed message */
      Ogre::String str; /**< String related: for example: team filename */ 
}ProtocolParsedMessage;

/**************************
 * Message Types          *
 **************************/

/** Note: each turn, the team to act is responsible for the
 * physics and rules calculations/results. The other player 
 * just receive data from it. */

/*! Just to point that is wating for no message */
#define MESSAGE_NONE                    -1

/*! Ack: used to acknowledge that a message was received. NeedAck: 0. 
 * Data: MSG_TYPE of the received message. */
#define MESSAGE_ACK                     0x0
/*! Nack: on refuse of some message due to some restriction. NeedAck: 0.
 * Data: MSG_TYPE + NACK_REASON */
#define MESSAGE_NACK                    0x1
/*! Init connection. Need Ack: 1.
 * Data[0]: Game version Major.
 * Data[1]: Game version Minor. */
#define MESSAGE_INIT_CONNECTION         0x2
/*! Set field type. NeedAck: 1.
 *  Data[0]: Field constant. */
#define MESSAGE_SET_FIELD               0x3
/*! Set team. NeedAck: 1. 
 *   Data[0]: UPDATE_TYPE_TEAM_A or UPDATE_TYPE_TEAM_B
 *   Data[1..253] -> String with team file name. */
#define MESSAGE_SET_TEAM                0x4
/*! Set the match to begin. NeedAck: 1. Data: sender with ball pocession.
 * \note: The teamA is always responsible for clock checks and 
 *        ending the half. */
#define MESSAGE_BEGIN_HALF              0x5
/*! When Half goes to an end. NeedAck: 1. */
#define MESSAGE_END_HALF                0x6
/*! Update position. NeedAck: 1 when position is final (physics stoped), 
 *  0 when intermediary. Data: Disks, GKs and ball positions. */
#define MESSAGE_UPDATE_POSITIONS        0x7
 /*! Max number of positions a message can have. */
#define MAX_POSITIONS_PER_MESSAGE       4
/*!  I) Ball Position
         Data[0] -> 0
         Data[1..8] -> position.x (double)
         Data[9..16] -> position.y (double)
         Data[17..24] -> position.z (double)
         Data[25..32] -> angle.W (double)
         Data[33..40] -> angle.X (double)
         Data[41..48] -> angle.Y (double)
         Data[49..56] -> angle.Z (double)
         Data[57..249] -> unused */
#define UPDATE_TYPE_BALL   0
/*!  II) Team A Positions
         Data[0] -> 1
         Data[1] -> Total positions defined
         Data[2+(n-1)*49] -> disk number (12 for goal keeper) n -> [1,5].
         Data[3+(n-1)*49..10+(n-1)*49] -> position.x (double)
         Data[11+(n-1)*49..18+(n-1)*49] -> position.y (double)
         Data[19+(n-1)*49..26+(n-1)*49] -> position.z (double)
         Data[27+(n-1)*49..34+(n-1)*49] -> angle.w (double)
         Data[35+(n-1)*49..42+(n-1)*49] -> angle.x (double)
         Data[43+(n-1)*49..50+(n-1)*49] -> angle.y (double)
         Data[51+(n-1)*49..58+(n-1)*49] -> angle.z (double)
         Data[246..249] -> unused */
#define UPDATE_TYPE_TEAM_A  1
/*! III) Team B Positions
         Data[0] -> 2
         Data[1..249] -> Same as II (Team A Positions) */
#define UPDATE_TYPE_TEAM_B  2
/*!  IV) Team A positions edited by manual input.
         This message should not update replay.
         Data[0] -> 3
         Data[1..249] -> Same as II (Team A Positions) */
#define UPDATE_TYPE_MANUAL_TEAM_A_INPUT 3
/*!   V) Team A positions edited by manual input.
         This message should not update replay.
         Data[0] -> 3
         Data[1..249] -> Same as II (Team A Positions) */
#define UPDATE_TYPE_MANUAL_TEAM_B_INPUT 4
#define UPDATE_GK_INDEX    12
/*! Send a new rule result. NeedAck: 1. Data: Rule result state,
 * with any needed aditional data (ie: position of foul, etc).
 * data[0] -> rule state.
 * data[1] -> active team. */
#define MESSAGE_RULES_RESULT            0x8
/*! Send a message telling the user to positionate its gk to a shoot. 
 * Need ack: 1 */
#define MESSAGE_WILL_SHOOT              0x9
/*! Send a message telling the gk input is done.
 * Need ack: 1 */
#define MESSAGE_GOAL_KEEPER_DONE        0xA
/*! Send a message telling a disk collision happened, to other side play
 * corresponding sound. Need ack = 0.
 * data[0] -> which sound (SOUND_TYPE constant).
 * data[1..] -> position(x,y,z) where collision happened. */
#define MESSAGE_PLAY_SOUND              0xB
#define SOUND_TYPE_COLLISION            0x1
#define SOUND_TYPE_DISK_ACT             0x2
/*! Send a message telling that a goal happened;
 * NeedAck: 1
 * Data[0]: UPDATE_TYPE_TEAM_A or UPDATE_TYPE_TEAM_B, setting if is a teamA
 * or teamB goal. */
#define MESSAGE_GOAL                    0xC
/*! Send a message telling the user paused a game. Need ack: 1. */
#define MESSAGE_PAUSE                   0xD
/*! Send a message that will resume a paused game. Need ack: 1 */
#define MESSAGE_RESUME                  0xE
/*! Message sent when some part will exit.
 * Need ack: 0 (as connection will be closed)*/
#define MESSAGE_GOODBYE                 0xF

/**************************
 * NACK Reasons           *
 **************************/

/*! Simple nack with no reason defined. */
#define NACK_REASON_OTHER               0x0
/*! Was expecting a different message */
#define NACK_REASON_EXPECTED_ANOTHER    0x1
/*! Received message is unknown */
#define NACK_REASON_UNKNOW_MESSAGE      0x2
/*! It isn't possible to play against a distinct game version. */
#define NACK_REASON_DIFFERENT_VERSIONS  0x3
/*! The teams must not be equals. */
#define NACK_REASON_SAME_TEAMS          0x4


/** Max number of messages to keep qeued at the protocol */
#define PROTOCOL_MAX_QUEUED_MESSAGES    256

/*! The protocol interface, responsible
 * for creating / parsing and queuing BtSoccer protocol messages.
 * \note Successfull initial flow:
 *|====================================================|
 *|        Client            |        Server           |
 *|----------------------------------------------------|
 *|      INIT_CONNECTION     |                         |
 *|                          |          ACK            |
 *|                          |        SET_FIELD        |
 *|           ACK            |                         |
 *|                          |       SET_TEAM (A)      |
 *|           ACK            |                         |
 *|        SET_TEAM (B)      |                         |
 *|                          |        BEGIN_HALF       |
 *|           ACK            |                         |
 *|         BEGIN_HALF       |                         |
 *|                          |           ACK           |
 *|                          |     UPDATE_POSITIONS    |
 *|                          |          (...)          |
 *|                          |       RESULT_RULES      |
 *|           ACK            |                         | */
class Protocol
{
   public:
      /*! Constructor 
       * \param gameCenter if using game center for communication 
       * \param fieldConstant current size constant. */
      void initProtocol(bool gameCenter, int fieldConstant);
      /*! Destructor */
      void finishProtocol();
   
      /*! Set team filename of team played by protocol owner. */
      void setTeam(Ogre::String teamFileName);
      /*! \return get team filename of team played by protocol owner. */
      Ogre::String getTeam();
      /*! Set if will be teamA.
       * \param teamA true if team is teamA, false if teamB.
       * \note teamA always act as server. */
      void setIsTeamA(bool teamA);
      /*! \return if acting as teamA */
      bool isTeamA();
   
      /*! Send a init connection message, with game version. */
      void queueHello();
      /*! Send team filename to the messages to send queue
       * \param teamFile filename of the team. */
      void queueSetTeam(Ogre::String teamFile);
      /*! Queue to send the field information.
       * \param fieldConstant field type constant. */
      void queueSetField(int fieldConstant);

      /*! Queue a TeamPlayer update to its position/orientation to send.
       * \param teamA true if teamA false if teamB
       * \param manualInput true if position was defined manually,
      *                     false if is physic defined.
       * \param diskNumber number of the disk. 12 for goal keeper
       * \param pos position vector
       * \param angles angles vector
       * \param isFinalPosition treu if sending positions after physics
      *         was stable (and thus must receive ack). */
      void queueTeamPlayerUpdateToSend(bool teamA, bool manualInput,
            int diskNumber, Ogre::Vector3 pos, Ogre::Quaternion angles,
            bool isFinalPosition);

      /*! Queue a Ball update to its position/angles to send 
       * \param pos position vector
       * \param angles angles vector
       * \param isFinalPosition treu if sending positions after physics
       *         was stable (and thus must receive ack). */
      void queueBallUpdateToSend(Ogre::Vector3 pos, Ogre::Quaternion angles,
                                 bool isFinalPosition);

      /*! Queue a rule result message 
       * \param ruleState the current rule state
       * \param ballWithTeamA if ball pocession is with teamA or teamB */
      void queueRulesResult(int ruleState, bool ballWithTeamA);

      /*! Queue a message to tell opponent to positionate its gk to 
       * a goal shoot. */
      void queueWillShoot();
      /*! Queue a message that the user who was positionating its goalkeeper
       * tell the oponent it's done. */
      void queueGoalKeeperDone();
   
      /*! Queue a message telling opponent to play a sound on a position.
       * \param soundType SOUND_TYPE constant, describing which sound to play
       * \param pos position where sound effect should be played. */
      void queueSoundEffect(int soundType, Ogre::Vector3 pos);
   
      /*! Queue a message telling that a goal happened.
       * \param teamAGoal true if is teamA's goal, false if teamB. */
      void queueGoalHappened(bool teamAGoal);

      /*! Queue a message telling the user paused the game. */
      void queuePause();
      /*! Queue a message telling the user that previously paused a game,
       * resumed it. */
      void queueResume();
   
      /*! Queue a message telling the half ended. */
      void queueEndHalf();
   
      /*! Queue a message telling that will begin a half */
      void queueBeginHalf();

      /*! Parse a received message, populating the ProtocolParsedMessages
       * queue of its values.
       * \param msg pointer to the received message to parse.
       * \return false when received goodbye. */
      bool parseReceivedMessage(ProtocolMessage* msg);

      /*! Get the next message on the queue to send.
       * \return true if the message is defined. False if no more messages
       *         on the "send" queue.
       * \param msg pointer to the variable that will receive the messsage.
       * \note: this function will remove the message from the queue. */
      bool getNextMessageToSend(ProtocolMessage* msg);
      /*! Get the last message at the queue to send. */
      bool getLastMessageToSend(ProtocolMessage* msg);

      /*! Get the next received parsed message on the queue.
       * \return true if the message is defined. False if no more messages
       *         are on the "received" queue.
       * \param msg pointer to the variable that will receive the messsage.
       * \note: this function will remove the message from the queue. */
      bool getNextReceivedMessage(ProtocolParsedMessage* msg);
   
      /*! @return if protocol is using iOS game center */
      bool isUsingGameCenter();

   protected:

      /*! Queue an ack message to send */
      void queueAck();
      /*! Queue a nack message to send */
      void queueNack(char nackReaon, char extraInfo=0);
      /*! Define a message as a bye message */
      void defineGoodbye(ProtocolMessage* bye);

      /*! Queue a message to send
       * \param pointer to the message to queue.
       * \note: the message is copied on the queue, so the pointer
       *        can be deleted/freed without problems. */
      void queueMessage(ProtocolMessage* msg);

      /*! Queue a parsed message received
       * \param pointer to the message to queue.
       * \note: the message is copied on the queue, so the pointer
       *        can be deleted/freed without problems. */
      void queueParsedMessage(ProtocolParsedMessage* msg);

      /*! Queue a received ball update to the parsed queue. */
      void queueReceivedBallUpdate(ProtocolMessage* msg);
      /*! Queue a received team update to the parsed queue. */
      void queueReceivedTeamPlayerUpdate(ProtocolMessage* msg);
      /*! Queue a received setTeam message. */
      void queueReceivedSetTeam(ProtocolMessage* msg);
      /*! Queue a received setField message. */
      void queueReceivedSetField(ProtocolMessage* msg);
      /*! Queue a received resultRules message*/
      void queueReceivedRulesResult(ProtocolMessage* msg);
      /*! Queue a received sound-effect-to-play to the parsed queue. */
      void queueReceivedSoundEffect(ProtocolMessage* msg);
      /*! Queue a received goal to the parsed queue */
      void queueReceivedGoal(ProtocolMessage* msg);

   protected:
      static Ogre::String teamFile;       /**< File of the owners team*/
      static int fieldSize;               /**< Size of the field */

   private:
      /** Set a vector3 to the data vector.*/
      void setVector3(Ogre::Vector3 v, char* data);
      /** Parse a vector data to a double vector3 */
      void parseVector3(double* vec, char* data);
      void setQuaternion(Ogre::Quaternion q, char* data);
      void parseQuaternion(double* vec, char* data);
   
      /*! Check if will discard message based on received increment value.
       * \note always accept ack and nack.
       * @return true if will discard, false if will accept. */
      bool discardReceivedMessage(ProtocolMessage* msg);
   
      /*! Set the inc value to send, incrementing it. */
      void setSendIncValue(char* incValue);
   
      /*! Remove the message that was waiting for ack, usually after
      * receveing it. */
      void removeMessageWaitingForAck();
      /*! Check if is currently waiting for an ack.
       * \note: must not be called inside lock of mutexSend, as it also
       *   lock this muxed. (thus, if called inside, we'll get a dead lock*/
      bool checkIfWaitingForAck();

      /*! Messages queued to send  */
      static ProtocolMessage send[PROTOCOL_MAX_QUEUED_MESSAGES];
      /*! Current end of the send queue */
      static int endSend;
      /*! Current init of the send queue*/
      static int initSend;
      /*! Queue of parsed messages received */
      static ProtocolParsedMessage received[PROTOCOL_MAX_QUEUED_MESSAGES];
      /*! Current init of the received queue */
      static int initReceived;
      /*! Current end of the received queue */
      static int endReceived;
   
      /*! Current inc value of same message type. */
      static unsigned long curQueueToSendInc;
      /*! Current inc value from last received message  */
      static unsigned long curReceivedInc;
   
      /*! Keep the sizeof(double) */
      static unsigned long int doubleSize;

      static bool isForTeamA; /**< if the protocol is at the server */
      static bool usingGameCenter; /**< if is using protocol with gamecenter*/
      static bool isInited; /**< if the protocol was previous inited. */
   
      static ProtocolMessage* messageWaitingForAck; /**< Message that is 
                                                  currently waiting for ack. */
      /*! Ack and NACK must not respect the queue, and be direct sent. */
      static ProtocolMessage ackNackToSend;
      static bool haveAckOrNackToSend; /**< When must send a ack or nack */
      static Kobold::Timer waitingTimer; /**< Waiting for ack timer */

      static pthread_mutex_t mutexSend; /**< Mutex for send queue*/
      static pthread_mutex_t mutexReceived; /**< Mutex for received queue */

};

}

#endif


